# Різниця у мовах

Цей файл пояснює відмінності між **реалізацією SMoL** (що також SMoL використовуємий у SMoL Quizzes)
та мовою, представленою у статі (далі, *статтєвий SMoL*).

## Реалізація SMoL має більше мовних конструкцій

У статті ми пропускаємо наступні конструкції, тому що вони не мають відношення до будь-яких програм, які ми показували у статті:

- `let*` та `letrec`, які означають те саме, що й у Racket.

Ми пропускаємо наступні конструкції, оскільки вони не мають відношення до будь-яких неправильних уявлень, які ми представляємо в статті:

- оператори списків: `empty`, `cons`, `empty?`, та `append`
- функції вищого порядку: `filter`, `map`, `foldl`, `foldr`
- поєднання рядків: `++`
- рівність: `equal?`, яка перевіряє не структурну рівність
- логіка: `and`, `or`, та `not`
- незмінні вектори: `ivec`, `pair`, та `ipair` (ці оператори працюють як і їх m-версії але створюють незмінні вектори)
- тестування: `test`
- відладка: `spy`, яка друкує значення із відладочною інформацією
- предікати: `zero?`

## Реалізація SMoL має трі мовних рівня

Реалізація SMoL має трі рівня (наприклад,
`smol/fun`, `smol/state`, та
`smol/fun`) як пояснено у статті. Ці рівні відповідають до трьох тестів.

## The SMoL implementation permits more shadowing

Статтевий SMoL не вказує, чи локальні змінні, визначені в тілі функції, знаходяться в тому самому середовищі, що й параметри функції.
Наприклад, поведінка наступної програми не визначена
```
(deffun (f x)
  (defvar x 1)
  x)
(f 0)
```

Програма може або видати помилку (оскільки `x` визначено двічі в одному середовищі), або видати `1` (оскільки локальний `x` затіняє параметр `x`). Реалізація SMoL передбачає поведінку затінення.
